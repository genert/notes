{"componentChunkName":"component---src-templates-doc-js","path":"/ruby","result":{"data":{"doc":{"id":"c3840069-b479-5e32-bd9a-78c499699c52","title":"Ruby","description":"Ruby","excerpt":"Ruby Requirements Install  Ruby . History Yukihiro Matsumoto created Ruby in 1993. As a language, Ruby is interpreted, object-orientedâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Ruby\",\n  \"description\": \"Ruby\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"ruby\"\n  }, \"Ruby\"), mdx(\"h2\", {\n    \"id\": \"requirements\"\n  }, \"Requirements\"), mdx(\"p\", null, \"Install \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.ruby-lang.org/en/\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"Ruby\"), \".\"), mdx(\"h2\", {\n    \"id\": \"history\"\n  }, \"History\"), mdx(\"p\", null, \"Yukihiro Matsumoto created Ruby in 1993. As a language, Ruby is interpreted, object-oriented, dynamically typed language from a family of so-called scripting languages. Interpreted means that types are bound at execution time rather than compile time. Object-oriented means the language supports encapsulation, inheritance through classes, and polymorphism.\"), mdx(\"h2\", {\n    \"id\": \"programming-model\"\n  }, \"Programming model\"), mdx(\"p\", null, \"Ruby is a pure object-oriented language.\"), mdx(\"p\", null, \"Let's look at some basic objects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, \"irb(main):001:0> 4\\n=> 4\\nirb(main):002:0> 4.class\\n=> Integer\\nirb(main):003:0> 4 + 4\\n=> 8\\nirb(main):004:0> 4.methods\\n=> [:-@, :**, :<=>, :upto, :<<, :<=, :>=, :==, :chr, :===, :>>, :[], :%, :&, :inspect, :*, :+, :ord, :-, :/, :size, :succ, :<, :>, :to_int, :coerce, :to_s, :to_i, :to_f, :divmod, :to_r, :fdiv, :modulo, :remainder, :abs, :magnitude, :integer?, :floor, :ceil, :round, :truncate, :^, :odd?, :even?, :allbits?, :anybits?, :nobits?, :downto, :times, :pred, :pow, :bit_length, :digits, :lcm, :gcdlcm, :gcd, :numerator, :denominator, :rationalize, :next, :div, :|, :~, :+@, :eql?, :singleton_method_added, :i, :real?, :zero?, :nonzero?, :finite?, :infinite?, :step, :positive?, :negative?, :arg, :clone, :dup, :rect, :real, :imaginary, :imag, :abs2, :angle, :phase, :conjugate, :rectangular, :to_c, :polar, :conj, :quo, :between?, :clamp, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :instance_variable_get, :instance_variable_set, :instance_variables, :singleton_method, :method, :public_send, :define_singleton_method, :public_method, :extend, :to_enum, :enum_for, :=~, :!~, :respond_to?, :freeze, :object_id, :send, :display, :nil?, :hash, :class, :singleton_class, :itself, :yield_self, :then, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :equal?, :!, :__id__, :instance_exec, :!=, :instance_eval, :__send__]\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Everything in Ruby is an object\"), \". A numbr is a an object that has a class caled \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Integer\"), \", and the method called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"methods\"), \" returns an array of methods.\"), mdx(\"h2\", {\n    \"id\": \"decisions\"\n  }, \"Decisions\"), mdx(\"p\", null, \"Programs exist to make decisions, so it stands to reason that the way a language makes decisions is a central concept that shapes the way you code, and think, in a given language. Ruby is like most object-oriented and procedural languages:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, \"irb(main):001:0> x = 4\\n=> 4\\nirb(main):002:0> x < 5\\n=> true\\nirb(main):003:0> x <= 4\\n=> true\\nirb(main):004:0> x > 4\\n=> false\\nirb(main):005:0> false.class\\n=> FalseClass\\nirb(main):006:0> true.class\\n=> TrueClass\\n\")), mdx(\"p\", null, \"Ruby has expressions that evaluate to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"true\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"false\"), \". You can conditionally execute code with them:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, \"irb(main):001:0> x = 4\\n=> 4\\nirb(main):002:0> puts \\\"This appears to be false.\\\" unless x == 4\\n=> nil\\nirb(main):003:0> puts \\\"This appears to be true.\\\" if x == 4\\nThis appears to be true.\\n=> nil\\nirb(main):004:0> if x == 4\\nirb(main):005:1>    puts \\\"This appears to be true.\\\"\\nirb(main):006:1> end\\nThis appears to be true.\\n=> nil\\nirb(main):007:0> unless x == 4\\nirb(main):008:1>    puts \\\"This appears to be false.\\\"\\nirb(main):009:1> else\\nirb(main):010:1>    puts \\\"This appears to be true.\\\"\\nirb(main):011:1> end\\nThis appears to be true.\\n=> nil\\nirb(main):012:0> put \\\"This appears to be true.\\\" if not true\\n=> nil\\nirb(main):013:0> puts \\\"This appears to be true.\\\" if !true\\n=> nil\\n\")), mdx(\"p\", null, \"The design choice for conditionals is simple as you can use both block forms (if condition) or one-line forms. With latter you can express a single though in a line of code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ruby\"\n  }, \"order.calculate_tax unless order.nil?\\n\")), mdx(\"p\", null, \"Logical operators work like they do in C, C++, C#, and Java with a few minor exceptions.\"), mdx(\"h2\", {\n    \"id\": \"duck-typing\"\n  }, \"Duck Typing\"), mdx(\"p\", null, \"The first thing you need to know is how much protection Ruby will give you when you make a mistake with types. We're talking about type safety. Stongly typed languages check types for certain operations and check the types before you can do any damage:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, \"irb(main):001:0> 4 + \\\"four\\\"\\nTraceback (most recent call last):\\n        5: from /usr/bin/irb:23:in `<main>'\\n        4: from /usr/bin/irb:23:in `load'\\n        3: from /Library/Ruby/Gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `<top (required)>'\\n        2: from (irb):1\\n        1: from (irb):1:in `+'\\nTypeError (String can't be coerced into Integer)\\nirb(main):002:0> 4.class\\n=> Integer\\nirb(main):003:0> (4.0).class\\n=> Float\\nirb(main):004:0> 4 + 4.0\\n=> 8.0\\n\")), mdx(\"p\", null, \"Ruby behaves like a strongly typed language most of time, meaning you will get an error when types collide. Ruby makes type checks at runtime, not compile time. It is important to knw that Ruby does not do any type checking until you actually try to execude code. This concept is called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dynamic typing\"), \".\"), mdx(\"p\", null, \"While \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dynamic typing\"), \" has trade-offs, it does provide several advantages. For example, classes don't have to inherit from the same parent to be used in the same way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, \"irb(main):001:0> i = 0\\n=> 0\\nirb(main):002:0> a = [\\\"100.0\\\", 100.0]\\n=> [\\\"100.0\\\", 100.0]\\nirb(main):003:0> while i < 2\\nirb(main):004:1>    puts a[i].to_i\\nirb(main):005:1>    i = i + 1\\nirb(main):006:1> end\\n100\\n100\\n=> nil\\n\")), mdx(\"p\", null, \"This is duck typing in action. The first element of the array is a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"String\"), \", and the second is a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Float\"), \". The same code converts each to an integer via \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"to_i\"), \". Duck typing doesn't are what the underyling type might be. If it walks like a duck and quacks like a duck, it is a duck. In this case, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"quack\"), \" method is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"to_i\"), \".\"), mdx(\"p\", null, \"If you think about, then duck type is great example of \\\"interfaces philosophy\\\" where you should code interfaces rather than implementation. If an object has \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"push\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pop\"), \" methods, you can treat it like a stack. If it doesn't, you can't.\"));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"value":"Ruby"},{"value":"Requirements"},{"value":"History"},{"value":"Programming model"},{"value":"Decisions"},{"value":"Duck Typing"}]}},"pageContext":{"id":"c3840069-b479-5e32-bd9a-78c499699c52","slug":"/ruby","previous":null,"next":{"id":"3ef3dc22-ec1a-50f8-8790-5fc821388644","slug":"/"}}},"staticQueryHashes":["2468095761"]}